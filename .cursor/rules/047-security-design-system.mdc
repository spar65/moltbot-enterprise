---
description: Use when implementing UI components that communicate security status, request authentication, or handle sensitive operations
globs: "components/ui/**/*.tsx, components/security/**/*.tsx, app/**/*.tsx, styles/**/*.css"
---

# Security Design System Standards

## Context
- Security-related UI elements must be consistent and recognizable
- Users should develop a mental model of security in the application
- Security indicators need clear visual hierarchy and meaning
- Different security levels and states must be visually distinct
- Security interfaces should balance alerting with usability
- Consistent security patterns increase user trust and comprehension
- Security UI must follow accessibility standards for all users

## Requirements

### Security Visual Language

- **REQUIRED**: Use consistent iconography for security states across the application
- **REQUIRED**: Maintain a dedicated color palette for security indicators
- Apply consistent typography for security messages
- Implement standardized animation patterns for security operations

```typescript
// Good: Security icon system
export const SecurityIcons = {
  locked: <LockIcon className="security-icon locked" />,
  unlocked: <UnlockIcon className="security-icon unlocked" />,
  verified: <ShieldCheckIcon className="security-icon verified" />,
  warning: <AlertTriangleIcon className="security-icon warning" />,
  error: <AlertOctagonIcon className="security-icon error" />,
  info: <InfoIcon className="security-icon info" />
};

// Good: Security color tokens
:root {
  /* Security-specific color palette */
  --security-secure: #00845c;
  --security-warning: #f1a817;
  --security-danger: #e12029;
  --security-info: #2670e8;
  --security-neutral: #6e7a8a;
  
  /* Security level indicators */
  --security-level-1: #0070f3;
  --security-level-2: #7928ca;
  --security-level-3: #e12029;
}
```

### Security Component Library

- **REQUIRED**: Create reusable components for common security patterns
- Standardize layout and placement of security elements
- Ensure consistent spacing and sizing for security indicators
- Support dark mode for all security components

```typescript
// Good: Authentication status component
export function AuthStatusIndicator({ status }: { status: AuthStatus }) {
  return (
    <div className="auth-status-indicator">
      {status === 'authenticated' && (
        <>
          {SecurityIcons.verified}
          <span className="auth-status-text">Verified Session</span>
        </>
      )}
      {status === 'expiring-soon' && (
        <>
          {SecurityIcons.warning}
          <span className="auth-status-text">Session Expiring Soon</span>
        </>
      )}
      {status === 'expired' && (
        <>
          {SecurityIcons.error}
          <span className="auth-status-text">Session Expired</span>
        </>
      )}
    </div>
  );
}

// Good: Secure field component
export function SecureField({ 
  label, 
  sensitivity = 'standard',
  ...props 
}: SecureFieldProps) {
  return (
    <div className={`secure-field sensitivity-${sensitivity}`}>
      <label>
        {label}
        {sensitivity === 'high' && SecurityIcons.locked}
      </label>
      <div className="secure-input-wrapper">
        <input {...props} />
        {sensitivity === 'high' && <BlurOverlay />}
      </div>
    </div>
  );
}
```

### Security Messaging Framework

- **REQUIRED**: Create consistent pattern for security notifications
- Use appropriate urgency levels for different security events
- Apply standardized styling to security messages
- Include clear action steps in security notifications

```typescript
// Good: Security notice component
export function SecurityNotice({ 
  title, 
  message, 
  severity = 'info',
  actionText,
  onAction
}: SecurityNoticeProps) {
  return (
    <div className={`security-notice ${severity}`}>
      {SecurityIcons[severity]}
      <div className="security-notice-content">
        <h3 className="security-notice-title">{title}</h3>
        <p className="security-notice-message">{message}</p>
        {actionText && (
          <Button 
            className="security-notice-action"
            variant="security"
            size="sm"
            onClick={onAction}
          >
            {actionText}
          </Button>
        )}
      </div>
    </div>
  );
}

// Good: Security messaging context
export const SecurityMessagingContext = createContext<SecurityMessagingContextType>({
  addNotice: () => {},
  removeNotice: () => {},
  notices: []
});

export function SecurityMessagingProvider({ children }: { children: React.ReactNode }) {
  const [notices, setNotices] = useState<SecurityNotice[]>([]);
  
  const addNotice = useCallback((notice: SecurityNotice) => {
    // Log security event
    if (notice.severity === 'warning' || notice.severity === 'error') {
      logSecurityEvent(notice.type, notice.message);
    }
    
    setNotices(prev => [...prev, { id: Date.now(), ...notice }]);
  }, []);
  
  const removeNotice = useCallback((id: number) => {
    setNotices(prev => prev.filter(notice => notice.id !== id));
  }, []);
  
  return (
    <SecurityMessagingContext.Provider value={{ notices, addNotice, removeNotice }}>
      {children}
      <SecurityNoticeContainer notices={notices} onDismiss={removeNotice} />
    </SecurityMessagingContext.Provider>
  );
}
```

### Progressive Security UX

- Create a unified approach to progressive security challenges
- **REQUIRED**: Use standardized visualizations for security levels
- Maintain consistent UI patterns for step-up authentication
- Support multiple authentication methods with consistent UI

```typescript
// Good: Security level indicator
export function SecurityLevelIndicator({ level }: { level: 1 | 2 | 3 }) {
  return (
    <div className="security-level-indicator">
      <div className={`level-marker ${level >= 1 ? 'active' : ''}`} />
      <div className={`level-marker ${level >= 2 ? 'active' : ''}`} />
      <div className={`level-marker ${level >= 3 ? 'active' : ''}`} />
    </div>
  );
}

// Good: Step-up authentication
export function StepUpAuth({ 
  requiredLevel, 
  currentLevel,
  onComplete
}: StepUpAuthProps) {
  return (
    <SecurityDialogBase>
      <SecurityLevelIndicator level={requiredLevel} />
      <h2 className="security-dialog-title">Additional Verification Required</h2>
      <p className="security-dialog-message">
        This action requires security level {requiredLevel}.
      </p>
      <SecurityVerificationMethod level={requiredLevel} onComplete={onComplete} />
    </SecurityDialogBase>
  );
}
```

## Dependencies
- Related rules: [010-security-compliance.mdc](mdc:010-security-compliance.mdc), [046-session-validation.mdc](mdc:046-session-validation.mdc), [054-accessibility-requirements.mdc](mdc:054-accessibility-requirements.mdc)
- Required packages: @radix-ui/react-dialog, @radix-ui/react-toast (for accessible security dialogs and notifications)
- External standards: WCAG 2.1 AA compliance, OWASP security recommendations

## Testing Guidelines
- Test security components for accurate visual representation of security states
- Verify accessibility across all security indicators
- Ensure proper message handling for different security events
- Test consistent styling in light and dark modes
- Validate cross-browser rendering consistency
- Verify screen reader compatibility for security notifications

```typescript
// Example: Testing for security design system consistency
describe('Security Design System', () => {
  it('maintains consistent styling across security levels', () => {
    const { getByTestId } = render(
      <>
        <SecurityLevelIndicator data-testid="level1" level={1} />
        <SecurityLevelIndicator data-testid="level2" level={2} />
        <SecurityLevelIndicator data-testid="level3" level={3} />
      </>
    );
    
    // Get computed styles for each level indicator
    const level1Style = window.getComputedStyle(getByTestId('level1'));
    const level2Style = window.getComputedStyle(getByTestId('level2'));
    const level3Style = window.getComputedStyle(getByTestId('level3'));
    
    // Core structure should be identical
    expect(level1Style.borderRadius).toEqual(level2Style.borderRadius);
    expect(level2Style.borderRadius).toEqual(level3Style.borderRadius);
    
    // Security colors should follow the defined palette
    const level1Color = level1Style.getPropertyValue('--security-level-1');
    const level2Color = level2Style.getPropertyValue('--security-level-2');
    const level3Color = level3Style.getPropertyValue('--security-level-3');
    
    expect(level1Color).toBe('#0070f3');
    expect(level2Color).toBe('#7928ca');
    expect(level3Color).toBe('#e12029');
  });
  
  it('renders security notifications with appropriate accessibility attributes', () => {
    const { getByRole } = render(
      <SecurityNotice
        title="Security Alert"
        message="Your account password was changed recently."
        severity="warning"
        actionText="Review Activity"
        onAction={() => {}}
      />
    );
    
    // Should use appropriate ARIA roles
    const alert = getByRole('alert');
    expect(alert).toBeInTheDocument();
    
    // Should have appropriate focus management
    const actionButton = getByRole('button', { name: /review activity/i });
    expect(actionButton).toHaveFocus();
  });
});
```

## Implementation Checklist

- [ ] Security Icons: Implement a consistent set of security-related icons
- [ ] Color System: Define and use a security-specific color palette with appropriate contrast
- [ ] Component Library: Create reusable security UI components (notices, indicators, dialogs)
- [ ] Messaging Framework: Implement standardized security notification patterns
- [ ] Progressive Security: Design UI for different security levels and step-up authentication
- [ ] Accessibility: Ensure all security components meet accessibility requirements
- [ ] Dark Mode: Test security components in both light and dark modes
- [ ] User Testing: Validate security UI with actual users to ensure comprehension 
## See Also

### Documentation
- **`.cursor/docs/security-workflows.md`** - Security implementation patterns
- **`.cursor/docs/security-checklist.md`** - UI security checklist
- **`.cursor/docs/rules-guide.md`** - Understanding the rule system
- **`.cursor/rules/003-cursor-system-overview.mdc`** - System overview

### Tools
- **`.cursor/tools/check-auth-config.sh`** - Validate authentication UI flow
- **`.cursor/tools/scan-secrets.sh`** - Ensure no secrets in client code

### Related Rules
- @002-rule-application.mdc - Rule priority system
- @030-visual-design-system.mdc - Visual design standards
- @042-ui-component-architecture.mdc - UI component patterns
- @046-session-validation.mdc - Session security
- @054-accessibility-requirements.mdc - Accessibility for security UI

### Quick Start
1. **Read:** `.cursor/rules/003-cursor-system-overview.mdc`
2. **Follow:** Security UI patterns from `.cursor/docs/security-workflows.md`
3. **Validate:** `.cursor/tools/check-auth-config.sh` (auth flow working)
