---
description: 
globs: ""
alwaysApply: false
---
___
description: Use when implementing user-related features that need to work across the platform, including authentication, permissions, and user management
globs: "app/api/auth/**/*.{ts,js,tsx,jsx}, components/auth/**/*.{tsx,jsx}, lib/auth/**/*.{ts,js}"
___

# Platform User Features

## Context
- AgentMinder manages users at both platform and organization levels
- User identity and authentication must be consistent across the platform
- Permissions vary based on user roles at platform and organization levels
- User preferences and settings need to be maintained across sessions
- Secure user data handling is essential for compliance and trust

## Requirements

### User Authentication

- Implement secure authentication using Clerk or similar identity provider
- Support multiple authentication methods (email/password, SSO, OAuth)
- Maintain consistent session management across all parts of the application
- Apply proper CSRF protection for all authentication flows
- Provide clear feedback for authentication failures

```typescript
// Good: Authentication component with multiple providers
import { SignIn } from "@clerk/nextjs";

export function AuthenticationForm() {
  return (
    <div className="mx-auto flex w-full flex-col justify-center space-y-6 sm:w-[350px]">
      <div className="flex flex-col space-y-2 text-center">
        <h1 className="text-2xl font-semibold tracking-tight">
          Welcome to AgentMinder
        </h1>
        <p className="text-sm text-muted-foreground">
          Sign in to your account to continue
        </p>
      </div>
      
      <SignIn 
        path="/sign-in"
        routing="path"
        signUpUrl="/sign-up"
        redirectUrl="/dashboard"
        appearance={{
          elements: {
            formButtonPrimary: "bg-primary text-primary-foreground hover:bg-primary/90",
            card: "bg-card border border-border",
          },
        }}
      />
    </div>
  );
}
```

### User Identity Management

- Ensure unique user identification across the platform
- Create a consistent user profile data structure
- Implement proper user onboarding and account setup flows
- Support profile updates and preference management
- Handle account deactivation and deletion securely

```typescript
// Good: User profile schema implementation
import { z } from "zod";

// User schema for validation
export const userProfileSchema = z.object({
  id: z.string().optional(), // Generated by auth provider
  email: z.string().email({
    message: "Please enter a valid email address",
  }),
  name: z.string().min(2, {
    message: "Name must be at least 2 characters",
  }),
  image: z.string().url().optional(),
  title: z.string().optional(),
  bio: z.string().max(160).optional(),
  location: z.string().optional(),
  timezone: z.string().optional(),
  notificationPreferences: z.object({
    email: z.boolean().default(true),
    browser: z.boolean().default(true),
    mobile: z.boolean().default(true),
  }).optional(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
});

export type UserProfile = z.infer<typeof userProfileSchema>;

// Usage for profile update
export async function updateUserProfile(userId: string, data: Partial<UserProfile>) {
  // Validate data
  const validated = userProfileSchema.partial().parse(data);
  
  try {
    // Update in database
    const updatedUser = await db.user.update({
      where: { id: userId },
      data: {
        ...validated,
        updatedAt: new Date(),
      },
    });
    
    // Sync with auth provider if needed
    if (validated.email || validated.name) {
      await syncAuthProviderProfile(userId, validated);
    }
    
    return updatedUser;
  } catch (error) {
    logger.error("Failed to update user profile", { userId, error });
    throw new Error("Failed to update user profile");
  }
}
```

### Permission Management

- Implement role-based access control (RBAC) for platform features
- Support organization-level roles and permissions
- Create a flexible permission model that can evolve with the platform
- Add permission checks in UI components and API routes
- Provide clear feedback for permission-denied scenarios

```typescript
// Good: Permission checking middleware
import { NextApiRequest, NextApiResponse } from "next";
import { getAuth } from "@clerk/nextjs/server";

// Define permission types
export type Permission = 
  | "platform:admin"
  | "platform:user"
  | "org:admin"
  | "org:member"
  | "org:viewer";

// Get user permissions
export async function getUserPermissions(userId: string): Promise<Permission[]> {
  // Get platform-level roles
  const platformRoles = await db.userRole.findMany({
    where: { userId },
  });
  
  // Map roles to permissions
  const permissions: Permission[] = platformRoles.flatMap(role => {
    switch (role.name) {
      case "admin":
        return ["platform:admin", "platform:user"];
      case "user":
        return ["platform:user"];
      default:
        return [];
    }
  });
  
  return permissions;
}

// Get organization-specific permissions
export async function getUserOrgPermissions(
  userId: string,
  orgId: string
): Promise<Permission[]> {
  const member = await db.organizationMember.findUnique({
    where: {
      userId_organizationId: {
        userId,
        organizationId: orgId,
      },
    },
  });
  
  if (!member) return [];
  
  switch (member.role) {
    case "owner":
    case "admin":
      return ["org:admin", "org:member", "org:viewer"];
    case "member":
      return ["org:member", "org:viewer"];
    case "viewer":
      return ["org:viewer"];
    default:
      return [];
  }
}

// Permission middleware
export function withPermission(permission: Permission) {
  return async (req: NextApiRequest, res: NextApiResponse, next: () => void) => {
    const { userId } = getAuth(req);
    
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    
    // Get permissions
    let permissions = await getUserPermissions(userId);
    
    // Add org permissions if org ID provided
    const orgId = req.headers["x-organization-id"] as string;
    if (orgId) {
      const orgPermissions = await getUserOrgPermissions(userId, orgId);
      permissions = [...permissions, ...orgPermissions];
    }
    
    // Check permission
    if (!permissions.includes(permission)) {
      return res.status(403).json({ error: "Forbidden" });
    }
    
    // Permission granted, continue
    return next();
  };
}

// Usage in API route
export default withPermission("org:admin")(async (req, res) => {
  // Handle the request for org admins only
  // ...
});
```

### User Session Management

- Implement secure session handling across the application
- Support multiple active sessions with proper device management
- Add session timeout and refresh mechanisms
- Create audit trails for important session events
- Allow users to review and terminate active sessions

```typescript
// Good: Session management component
export function ActiveSessionsTable() {
  const [sessions, setSessions] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const { toast } = useToast();
  
  useEffect(() => {
    async function loadSessions() {
      try {
        setIsLoading(true);
        const response = await fetch('/api/user/sessions');
        const data = await response.json();
        setSessions(data.sessions);
      } catch (error) {
        toast({
          title: "Failed to load sessions",
          description: "Please try again later",
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
      }
    }
    
    loadSessions();
  }, [toast]);
  
  const handleTerminateSession = async (sessionId) => {
    try {
      await fetch(`/api/user/sessions/${sessionId}`, {
        method: 'DELETE',
      });
      
      // Remove from local state
      setSessions(sessions.filter(session => session.id !== sessionId));
      
      toast({
        title: "Session terminated",
        description: "The session has been successfully ended",
      });
    } catch (error) {
      toast({
        title: "Failed to terminate session",
        description: "Please try again later",
        variant: "destructive",
      });
    }
  };
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold tracking-tight">Active Sessions</h2>
      
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Device</TableHead>
            <TableHead>Location</TableHead>
            <TableHead>Last Active</TableHead>
            <TableHead>Status</TableHead>
            <TableHead className="text-right">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {sessions.length === 0 ? (
            <TableRow>
              <TableCell colSpan={5} className="text-center">
                No active sessions found
              </TableCell>
            </TableRow>
          ) : (
            sessions.map((session) => (
              <TableRow key={session.id}>
                <TableCell>
                  <div className="flex items-center gap-2">
                    <DeviceIcon type={session.deviceType} className="h-4 w-4" />
                    <span>{session.deviceName}</span>
                    {session.isCurrent && (
                      <Badge variant="outline" className="ml-2">
                        Current
                      </Badge>
                    )}
                  </div>
                </TableCell>
                <TableCell>{session.location || 'Unknown'}</TableCell>
                <TableCell>{formatDate(session.lastActiveAt)}</TableCell>
                <TableCell>
                  <Badge 
                    variant={session.isActive ? "default" : "secondary"}
                  >
                    {session.isActive ? 'Active' : 'Inactive'}
                  </Badge>
                </TableCell>
                <TableCell className="text-right">
                  <Button
                    variant="ghost"
                    size="sm"
                    disabled={session.isCurrent}
                    onClick={() => handleTerminateSession(session.id)}
                  >
                    {session.isCurrent ? 'Current Session' : 'Terminate'}
                  </Button>
                </TableCell>
              </TableRow>
            ))
          )}
        </TableBody>
      </Table>
    </div>
  );
}
```

### User Preferences

- Create a unified system for user preferences
- Support theme preferences (light/dark mode)
- Implement notification preferences
- Add UI customization options
- Persist preferences across sessions and devices

```typescript
// Good: User preferences hook
import { useState, useEffect } from 'react';
import { useDebounce } from '@/hooks/useDebounce';
import { useAuth } from '@clerk/nextjs';

export interface UserPreferences {
  theme: 'light' | 'dark' | 'system';
  sidebarCollapsed: boolean;
  notifications: {
    email: boolean;
    push: boolean;
    inApp: boolean;
  };
  dashboard: {
    defaultView: 'list' | 'grid';
    hiddenWidgets: string[];
  };
}

const defaultPreferences: UserPreferences = {
  theme: 'system',
  sidebarCollapsed: false,
  notifications: {
    email: true,
    push: true,
    inApp: true,
  },
  dashboard: {
    defaultView: 'list',
    hiddenWidgets: [],
  },
};

export function useUserPreferences() {
  const { userId } = useAuth();
  const [preferences, setPreferences] = useState<UserPreferences>(defaultPreferences);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  
  // Load preferences
  useEffect(() => {
    if (!userId) return;
    
    async function loadPreferences() {
      try {
        setIsLoading(true);
        const response = await fetch('/api/user/preferences');
        
        if (response.ok) {
          const data = await response.json();
          setPreferences({
            ...defaultPreferences,
            ...data.preferences,
          });
        }
      } catch (error) {
        console.error('Failed to load preferences', error);
      } finally {
        setIsLoading(false);
      }
    }
    
    loadPreferences();
  }, [userId]);
  
  // Debounce changes to reduce API calls
  const debouncedPreferences = useDebounce(preferences, 500);
  
  // Save preferences when they change
  useEffect(() => {
    if (!userId || isLoading) return;
    
    async function savePreferences() {
      try {
        setIsSaving(true);
        await fetch('/api/user/preferences', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ preferences: debouncedPreferences }),
        });
      } catch (error) {
        console.error('Failed to save preferences', error);
      } finally {
        setIsSaving(false);
      }
    }
    
    savePreferences();
  }, [debouncedPreferences, userId, isLoading]);
  
  // Update a specific preference
  const updatePreference = <K extends keyof UserPreferences>(
    key: K,
    value: UserPreferences[K]
  ) => {
    setPreferences(prev => ({
      ...prev,
      [key]: value,
    }));
  };
  
  // Update a nested preference
  const updateNestedPreference = <
    K extends keyof UserPreferences,
    N extends keyof UserPreferences[K]
  >(
    key: K,
    nestedKey: N,
    value: UserPreferences[K][N]
  ) => {
    setPreferences(prev => ({
      ...prev,
      [key]: {
        ...prev[key],
        [nestedKey]: value,
      },
    }));
  };
  
  return {
    preferences,
    isLoading,
    isSaving,
    updatePreference,
    updateNestedPreference,
  };
}
```

### User Organization Relationships

- Define clear models for user-organization relationships
- Support users belonging to multiple organizations
- Implement organization switching functionality
- Handle organization invites and membership requests
- Maintain history of organization memberships

```typescript
// Good: Organization membership management
// Database schema (Prisma example)
/*
model User {
  id          String   @id
  email       String   @unique
  name        String
  memberships OrganizationMember[]
}

model Organization {
  id          String   @id @default(cuid())
  name        String
  members     OrganizationMember[]
  invites     OrganizationInvite[]
}

model OrganizationMember {
  userId        String
  organizationId String
  role          String
  joinedAt      DateTime @default(now())
  
  user          User @relation(fields: [userId], references: [id])
  organization  Organization @relation(fields: [organizationId], references: [id])
  
  @@id([userId, organizationId])
}

model OrganizationInvite {
  id            String   @id @default(cuid())
  email         String
  organizationId String
  role          String
  token         String   @unique
  expiresAt     DateTime
  invitedBy     String
  createdAt     DateTime @default(now())
  
  organization  Organization @relation(fields: [organizationId], references: [id])
}
*/

// Organization invitation component
export function OrganizationInviteForm() {
  const { register, handleSubmit, reset, formState: { errors, isSubmitting } } = useForm();
  const { organization } = useOrganization();
  const { toast } = useToast();
  
  const onSubmit = async (data) => {
    try {
      const response = await fetch('/api/organizations/invites', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: data.email,
          role: data.role,
          organizationId: organization.id,
        }),
      });
      
      if (!response.ok) {
        throw new Error('Failed to send invitation');
      }
      
      toast({
        title: "Invitation sent",
        description: `An invitation has been sent to ${data.email}`,
      });
      
      reset();
    } catch (error) {
      toast({
        title: "Failed to send invitation",
        description: error.message || "Please try again later",
        variant: "destructive",
      });
    }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="email">Email address</Label>
        <Input
          id="email"
          type="email"
          {...register('email', { 
            required: "Email is required",
            pattern: {
              value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
              message: "Invalid email address"
            }
          })}
        />
        {errors.email && (
          <p className="text-sm text-red-500">{errors.email.message}</p>
        )}
      </div>
      
      <div className="space-y-2">
        <Label htmlFor="role">Role</Label>
        <Select {...register('role', { required: "Role is required" })}>
          <option value="admin">Admin</option>
          <option value="member">Member</option>
          <option value="viewer">Viewer</option>
        </Select>
        {errors.role && (
          <p className="text-sm text-red-500">{errors.role.message}</p>
        )}
      </div>
      
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Sending..." : "Send Invitation"}
      </Button>
    </form>
  );
}
```

### User Profile and Settings

- Implement a comprehensive user profile system
- Support profile completeness indicators
- Create a centralized settings interface
- Add account security settings (password, 2FA)
- Include connected accounts and integrations management

```typescript
// Good: User settings page layout
export function UserSettingsLayout({ children }) {
  return (
    <div className="container py-8">
      <div className="flex flex-col gap-8 md:flex-row">
        <aside className="md:w-64 shrink-0">
          <nav className="space-y-1">
            <SettingsNavLink href="/settings/profile">
              Profile
            </SettingsNavLink>
            <SettingsNavLink href="/settings/account">
              Account Security
            </SettingsNavLink>
            <SettingsNavLink href="/settings/notifications">
              Notifications
            </SettingsNavLink>
            <SettingsNavLink href="/settings/preferences">
              Preferences
            </SettingsNavLink>
            <SettingsNavLink href="/settings/api-keys">
              API Keys
            </SettingsNavLink>
            <SettingsNavLink href="/settings/sessions">
              Active Sessions
            </SettingsNavLink>
            <SettingsNavLink href="/settings/billing">
              Billing
            </SettingsNavLink>
          </nav>
        </aside>
        
        <main className="flex-1">
          <div className="space-y-6">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
}

// Settings navigation link component
function SettingsNavLink({ href, children }) {
  const router = useRouter();
  const isActive = router.pathname === href;
  
  return (
    <Link
      href={href}
      className={cn(
        "flex items-center gap-2 rounded-md px-3 py-2 text-sm font-medium",
        isActive
          ? "bg-muted text-foreground"
          : "text-muted-foreground hover:bg-muted hover:text-foreground"
      )}
    >
      {children}
    </Link>
  );
}
```

## Best Practices

1. **Security First**: Always prioritize security for user-related features
2. **Progressive Enhancement**: Build a solid core experience, then enhance
3. **Feedback Quality**: Provide clear, helpful feedback for user actions
4. **Accessibility**: Ensure all user features are accessible
5. **Performance**: Optimize user features for quick interactions
6. **Error Handling**: Implement comprehensive error handling for user flows
7. **Testing**: Test user features across different scenarios and edge cases 
## See Also

### Documentation
- **`.cursor/docs/ai-workflows.md`** - Platform user workflows
- **`.cursor/docs/security-workflows.md#auth0-integration-workflow`** - User auth patterns
- **`.cursor/rules/003-cursor-system-overview.mdc`** - System overview (READ THIS FIRST)

### Guides
- **`guides/Multi-Tenant-Architecture-Complete-Guide.md`** ‚≠ê **NEW!** - User isolation patterns
- **`guides/Secrets-Management-Complete-Guide.md`** - Manage user credentials
- **`guides/Database-Operations-Complete-Guide.md`** - User data management

### Tools (USE THESE!)
- **`.cursor/tools/inspect-model.sh`** - Check user/platform models
  ```bash
  ./.cursor/tools/inspect-model.sh User
  ./.cursor/tools/inspect-model.sh Organization
  # Check user-organization relationships!
  ```
- **`.cursor/tools/check-auth-config.sh`** - Validate user auth
- **`.cursor/tools/check-infrastructure.sh`** - Verify user management setup

### Related Rules
- @002-rule-application.mdc - Source of Truth Hierarchy (schema first!)
- @014-third-party-auth.mdc - Authentication patterns
- @016-platform-hierarchy.mdc - Platform hierarchy (critical!)
- @019-auth0-integration.mdc - Auth0 user management
- @025-multi-tenancy.mdc - Multi-tenant user isolation (CRITICAL!)
- @070-user-crud-operations.mdc - User CRUD patterns
- @224-secrets-management.mdc - User credential management
- @374-authentication-architecture-standards.mdc - Auth architecture
- @440-admin-user-management.mdc - Admin user patterns

### Quick Start
1. **Schema:** `.cursor/tools/inspect-model.sh User` (user-org link)
2. **Auth:** See @019-auth0-integration.mdc (user authentication)
3. **Isolate:** Follow @025-multi-tenancy.mdc (organization boundaries)
4. **Guide:** Read `guides/Multi-Tenant-Architecture-Complete-Guide.md` (patterns!)
