---
description: Generate production-ready TypeScript SDKs when building API products to provide excellent developer experience and accelerate customer integration
globs: "packages/**/*, sdk/**/*, client-libraries/**/*"
---

# SDK Generation Standards

## Context

When building API-first SaaS products, providing a high-quality SDK dramatically improves developer experience, reduces time-to-integration, and increases product adoption. Based on successful GiDanc Health Check SDK implementation, this rule codifies the pattern for building production-ready TypeScript SDKs.

**When to apply:**
- Building new API products
- Adding SDK support for existing APIs
- Improving existing SDK quality
- Supporting multiple programming languages

## Requirements

### 1. Project Structure

#### Package Organization

**REQUIRED**: Use monorepo structure for SDK packages:

```
packages/
‚îî‚îÄ‚îÄ sdk-ts/                    # TypeScript SDK package
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ client.ts          # Main SDK client
    ‚îÇ   ‚îú‚îÄ‚îÄ types.ts           # Type definitions
    ‚îÇ   ‚îú‚îÄ‚îÄ cli.ts             # CLI tool (optional but recommended)
    ‚îÇ   ‚îú‚îÄ‚îÄ index.ts           # Public API exports
    ‚îÇ   ‚îî‚îÄ‚îÄ __tests__/         # Test suites
    ‚îÇ       ‚îî‚îÄ‚îÄ client.test.ts # Comprehensive tests
    ‚îú‚îÄ‚îÄ dist/                  # Compiled JavaScript output
    ‚îú‚îÄ‚îÄ package.json           # Package configuration
    ‚îú‚îÄ‚îÄ tsconfig.json          # TypeScript config
    ‚îú‚îÄ‚îÄ README.md              # SDK documentation
    ‚îî‚îÄ‚îÄ EXAMPLES.md            # Usage examples
```

**Rationale**: Monorepo structure allows:
- Shared dependencies with main application
- Easier testing against actual API
- Version coordination
- Simplified development workflow

---

### 2. Core SDK Client

#### Client Class Architecture

**REQUIRED**: Implement SDK as a class with constructor config and method-based API:

```typescript
// src/client.ts
export interface SDKConfig {
  apiKey: string;                    // REQUIRED: Authentication
  baseUrl?: string;                  // OPTIONAL: Custom API URL
  timeout?: number;                  // OPTIONAL: Request timeout (default: 30000ms)
  retryConfig?: {                    // OPTIONAL: Retry logic
    maxRetries: number;
    backoff: 'exponential' | 'linear';
  };
}

export class YourProductClient {
  private apiKey: string;
  private baseUrl: string;
  private timeout: number;

  constructor(config: SDKConfig) {
    // Validation
    if (!config.apiKey) {
      throw new Error('API key is required');
    }
    if (!config.apiKey.startsWith('your_prefix_')) {
      throw new Error('Invalid API key format');
    }

    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://api.yourproduct.com/v1';
    this.timeout = config.timeout || 30000;
  }

  // Public API methods...
}
```

**Example from GiDanc:**
```typescript
const client = new HealthCheckClient({
  apiKey: 'hck_your_api_key_here',
  baseUrl: 'https://api.gidanc.com/v1',
  timeout: 30000,
});
```

---

### 3. Type Definitions

#### Comprehensive Type System

**REQUIRED**: Define types for all API requests and responses:

```typescript
// src/types.ts

// ========================================
// Configuration Types
// ========================================
export interface SDKConfig {
  apiKey: string;
  baseUrl?: string;
  timeout?: number;
}

// ========================================
// Request Types
// ========================================
export interface CreateResourceRequest {
  name: string;
  description?: string;
  metadata?: Record<string, unknown>;
}

export interface ListResourcesRequest {
  page?: number;
  pageSize?: number;
  filters?: {
    status?: 'active' | 'inactive';
    createdAfter?: string;
  };
}

// ========================================
// Response Types
// ========================================
export interface Resource {
  id: string;
  organizationId: string;
  name: string;
  description: string | null;
  status: 'active' | 'inactive';
  createdAt: string;
  updatedAt: string;
  metadata: Record<string, unknown>;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    pageSize: number;
    totalPages: number;
    totalItems: number;
  };
}

// ========================================
// Error Types
// ========================================
export class SDKError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public details?: unknown
  ) {
    super(message);
    this.name = 'SDKError';
  }
}

export class AuthenticationError extends SDKError {
  constructor(message: string = 'Invalid API key') {
    super(message, 401);
    this.name = 'AuthenticationError';
  }
}

export class RateLimitError extends SDKError {
  constructor(
    message: string = 'Rate limit exceeded',
    public resetAt?: number
  ) {
    super(message, 429);
    this.name = 'RateLimitError';
  }
}

export class ValidationError extends SDKError {
  constructor(message: string, details?: unknown) {
    super(message, 400, details);
    this.name = 'ValidationError';
  }
}
```

---

### 4. SDK Methods

#### Pattern: One Method Per API Endpoint

**REQUIRED**: Create SDK methods that mirror API endpoints with clear naming:

```typescript
export class YourProductClient {
  // ========================================
  // CRUD Operations
  // ========================================

  /**
   * Create a new resource
   * @param request Resource creation parameters
   * @returns Created resource
   */
  async createResource(
    request: CreateResourceRequest
  ): Promise<Resource> {
    return this.request<Resource>('POST', '/resources', request);
  }

  /**
   * List resources with optional filtering
   * @param request List parameters
   * @returns Paginated list of resources
   */
  async listResources(
    request?: ListResourcesRequest
  ): Promise<PaginatedResponse<Resource>> {
    const params = new URLSearchParams();
    if (request?.page) params.append('page', String(request.page));
    if (request?.pageSize) params.append('pageSize', String(request.pageSize));
    if (request?.filters?.status) {
      params.append('status', request.filters.status);
    }

    return this.request<PaginatedResponse<Resource>>(
      'GET',
      `/resources?${params.toString()}`
    );
  }

  /**
   * Get a specific resource by ID
   * @param id Resource ID
   * @returns Resource details
   */
  async getResource(id: string): Promise<Resource> {
    return this.request<Resource>('GET', `/resources/${id}`);
  }

  /**
   * Update a resource
   * @param id Resource ID
   * @param updates Resource updates
   * @returns Updated resource
   */
  async updateResource(
    id: string,
    updates: Partial<CreateResourceRequest>
  ): Promise<Resource> {
    return this.request<Resource>('PATCH', `/resources/${id}`, updates);
  }

  /**
   * Delete a resource
   * @param id Resource ID
   */
  async deleteResource(id: string): Promise<void> {
    await this.request<void>('DELETE', `/resources/${id}`);
  }

  // ========================================
  // Async Operations with Polling
  // ========================================

  /**
   * Start an async operation
   * @param config Operation configuration
   * @returns Operation status with runId
   */
  async startOperation(
    config: OperationConfig
  ): Promise<OperationStatus> {
    return this.request<OperationStatus>('POST', '/operations', config);
  }

  /**
   * Get operation status
   * @param runId Operation run ID
   * @returns Current status
   */
  async getOperationStatus(runId: string): Promise<OperationStatus> {
    return this.request<OperationStatus>('GET', `/operations/${runId}/status`);
  }

  /**
   * Wait for operation to complete (convenience method)
   * @param runId Operation run ID
   * @param options Polling options
   * @returns Final operation result
   */
  async waitForCompletion(
    runId: string,
    options?: {
      pollInterval?: number;      // Default: 5000ms
      maxWaitTime?: number;       // Default: 300000ms (5 min)
      onProgress?: (status: OperationStatus) => void;
    }
  ): Promise<OperationResult> {
    const pollInterval = options?.pollInterval || 5000;
    const maxWaitTime = options?.maxWaitTime || 300000;
    const startTime = Date.now();

    while (true) {
      const status = await this.getOperationStatus(runId);

      // Call progress callback
      if (options?.onProgress) {
        options.onProgress(status);
      }

      // Check if complete
      if (status.status === 'completed') {
        return this.getOperationResult(runId);
      }

      // Check if failed
      if (status.status === 'failed') {
        throw new SDKError(
          `Operation failed: ${status.error}`,
          500,
          status
        );
      }

      // Check timeout
      if (Date.now() - startTime > maxWaitTime) {
        throw new SDKError(
          `Operation timed out after ${maxWaitTime}ms`,
          408
        );
      }

      // Wait before next poll
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
  }

  /**
   * Run operation and wait for completion (combines start + wait)
   * @param config Operation configuration
   * @param pollOptions Polling options
   * @returns Final operation result
   */
  async runOperation(
    config: OperationConfig,
    pollOptions?: Parameters<typeof this.waitForCompletion>[1]
  ): Promise<OperationResult> {
    const status = await this.startOperation(config);
    return this.waitForCompletion(status.runId, pollOptions);
  }

  // ========================================
  // Private HTTP Request Handler
  // ========================================

  private async request<T>(
    method: string,
    path: string,
    body?: unknown
  ): Promise<T> {
    const url = `${this.baseUrl}${path}`;

    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`,
      },
      body: body ? JSON.stringify(body) : undefined,
      signal: AbortSignal.timeout(this.timeout),
    });

    // Handle errors
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));

      // Specific error types
      if (response.status === 401) {
        throw new AuthenticationError();
      }
      if (response.status === 429) {
        const resetAt = response.headers.get('X-RateLimit-Reset');
        throw new RateLimitError(
          errorData.message,
          resetAt ? parseInt(resetAt) : undefined
        );
      }
      if (response.status === 400) {
        throw new ValidationError(
          errorData.message || 'Validation failed',
          errorData.details
        );
      }

      // Generic error
      throw new SDKError(
        errorData.message || 'Request failed',
        response.status,
        errorData
      );
    }

    // Parse response
    if (response.status === 204 || method === 'DELETE') {
      return undefined as T;
    }

    return response.json();
  }
}
```

---

### 5. CLI Tool (Optional but Recommended)

#### Command-Line Interface for CI/CD

**RECOMMENDED**: Provide CLI tool for easy integration in scripts:

```typescript
// src/cli.ts
#!/usr/bin/env node

import { program } from 'commander';
import { YourProductClient } from './client';

program
  .name('yourproduct')
  .description('CLI tool for YourProduct API')
  .version('1.0.0');

program
  .command('run')
  .description('Run an operation')
  .requiredOption('--api-key <key>', 'API key')
  .requiredOption('--param <value>', 'Operation parameter')
  .option('--exit-on-fail', 'Exit with error code on failure')
  .action(async (options) => {
    try {
      const client = new YourProductClient({
        apiKey: options.apiKey,
      });

      console.log('üöÄ Starting operation...');

      const result = await client.runOperation(
        { param: options.param },
        {
          onProgress: (status) => {
            if (status.progress) {
              console.log(`Progress: ${status.progress.percentage}%`);
            }
          },
        }
      );

      console.log('‚úÖ Operation completed successfully');
      console.log(JSON.stringify(result, null, 2));

      if (options.exitOnFail && !result.success) {
        process.exit(1);
      }
    } catch (error: any) {
      console.error('‚ùå Error:', error.message);
      if (options.exitOnFail) {
        process.exit(1);
      }
    }
  });

program.parse();
```

**Package.json configuration:**
```json
{
  "bin": {
    "yourproduct": "./dist/cli.js"
  }
}
```

**Usage:**
```bash
# Install globally
npm install -g @yourcompany/sdk

# Use in scripts
yourproduct run --api-key xxx --param value --exit-on-fail
```

---

### 6. Testing Requirements

#### Comprehensive Test Coverage

**REQUIRED**: Achieve 80%+ test coverage with realistic tests:

```typescript
// src/__tests__/client.test.ts
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { YourProductClient, AuthenticationError, RateLimitError } from '../client';

describe('YourProductClient', () => {
  let client: YourProductClient;

  beforeEach(() => {
    client = new YourProductClient({
      apiKey: 'test_key_123',
      baseUrl: 'http://localhost:3000/api/v1',
    });
  });

  // ========================================
  // Constructor & Validation Tests
  // ========================================
  describe('Constructor', () => {
    it('should require API key', () => {
      expect(() => {
        new YourProductClient({ apiKey: '' });
      }).toThrow('API key is required');
    });

    it('should validate API key format', () => {
      expect(() => {
        new YourProductClient({ apiKey: 'invalid_key' });
      }).toThrow('Invalid API key format');
    });

    it('should use default base URL', () => {
      const client = new YourProductClient({ apiKey: 'test_key' });
      expect(client['baseUrl']).toBe('https://api.yourproduct.com/v1');
    });

    it('should accept custom base URL', () => {
      const client = new YourProductClient({
        apiKey: 'test_key',
        baseUrl: 'http://localhost:3000',
      });
      expect(client['baseUrl']).toBe('http://localhost:3000');
    });
  });

  // ========================================
  // CRUD Operation Tests
  // ========================================
  describe('createResource()', () => {
    it('should create a resource successfully', async () => {
      const mockResource = {
        id: '123',
        name: 'Test Resource',
        status: 'active',
        createdAt: '2024-01-01T00:00:00Z',
      };

      // Mock fetch response
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        json: async () => mockResource,
      });

      const result = await client.createResource({ name: 'Test Resource' });

      expect(result).toEqual(mockResource);
      expect(global.fetch).toHaveBeenCalledWith(
        'http://localhost:3000/api/v1/resources',
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            'Authorization': 'Bearer test_key_123',
          }),
        })
      );
    });

    it('should handle validation errors', async () => {
      global.fetch = jest.fn().mockResolvedValue({
        ok: false,
        status: 400,
        json: async () => ({
          message: 'Name is required',
          details: { field: 'name' },
        }),
      });

      await expect(
        client.createResource({ name: '' })
      ).rejects.toThrow(ValidationError);
    });
  });

  // ========================================
  // Error Handling Tests
  // ========================================
  describe('Error Handling', () => {
    it('should throw AuthenticationError for 401', async () => {
      global.fetch = jest.fn().mockResolvedValue({
        ok: false,
        status: 401,
        json: async () => ({ message: 'Invalid API key' }),
      });

      await expect(
        client.getResource('123')
      ).rejects.toThrow(AuthenticationError);
    });

    it('should throw RateLimitError for 429', async () => {
      global.fetch = jest.fn().mockResolvedValue({
        ok: false,
        status: 429,
        headers: new Map([['X-RateLimit-Reset', '1640000000']]),
        json: async () => ({ message: 'Rate limit exceeded' }),
      });

      await expect(
        client.getResource('123')
      ).rejects.toThrow(RateLimitError);
    });
  });

  // ========================================
  // Async Operation Tests
  // ========================================
  describe('waitForCompletion()', () => {
    it('should poll until completion', async () => {
      let callCount = 0;
      global.fetch = jest.fn().mockImplementation(() => {
        callCount++;
        if (callCount < 3) {
          return Promise.resolve({
            ok: true,
            json: async () => ({
              status: 'running',
              progress: { percentage: callCount * 30 },
            }),
          });
        }
        return Promise.resolve({
          ok: true,
          json: async () => ({ status: 'completed' }),
        });
      });

      const progressUpdates: number[] = [];
      await client.waitForCompletion('run-123', {
        pollInterval: 100,
        onProgress: (status) => {
          if (status.progress) {
            progressUpdates.push(status.progress.percentage);
          }
        },
      });

      expect(progressUpdates).toEqual([30, 60]);
      expect(callCount).toBeGreaterThanOrEqual(3);
    });

    it('should timeout if operation takes too long', async () => {
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        json: async () => ({ status: 'running' }),
      });

      await expect(
        client.waitForCompletion('run-123', {
          pollInterval: 100,
          maxWaitTime: 500,
        })
      ).rejects.toThrow('Operation timed out');
    });
  });
});
```

**Testing Checklist:**
- [ ] Constructor validation
- [ ] All CRUD operations
- [ ] Error handling (401, 429, 400, 500)
- [ ] Async operations with polling
- [ ] Progress callbacks
- [ ] Timeout handling
- [ ] Rate limit handling
- [ ] Type safety (TypeScript compilation)

---

### 7. Documentation Requirements

#### README.md

**REQUIRED**: Comprehensive README with:

1. **Quick Start** (5-line example)
2. **Installation** (npm install)
3. **Authentication** (API key setup)
4. **API Reference** (all methods documented)
5. **Error Handling** (typed error examples)
6. **CI/CD Integration** (GitHub Actions example)
7. **Support Links** (docs, issues, email)

**Template:**
```markdown
# YourProduct SDK for TypeScript

> One-line value proposition

## Quick Start

\`\`\`typescript
import { YourProductClient } from '@yourcompany/sdk';

const client = new YourProductClient({ apiKey: 'your_key' });
const result = await client.runOperation({ param: 'value' });
console.log(result);
\`\`\`

## Installation

\`\`\`bash
npm install @yourcompany/sdk
\`\`\`

## API Reference

### Constructor

...

### Methods

...

## Error Handling

...

## CI/CD Integration

...

## Support

- üìñ [Documentation](https://docs.yourproduct.com)
- üí¨ [GitHub Issues](https://github.com/yourcompany/sdk/issues)
- üìß [Email Support](mailto:support@yourproduct.com)
```

#### EXAMPLES.md

**REQUIRED**: Separate file with realistic examples:

```markdown
# SDK Examples

## Simple Operation

\`\`\`typescript
// Basic usage
\`\`\`

## Startup Script (Blocking on Failure)

\`\`\`typescript
// CI/CD pattern
\`\`\`

## Testing Multiple Configurations

\`\`\`typescript
// Batch processing
\`\`\`

## Advanced Error Handling

\`\`\`typescript
// Production-ready error handling
\`\`\`
```

---

### 8. Package Configuration

#### package.json

**REQUIRED**: Complete package.json:

```json
{
  "name": "@yourcompany/sdk",
  "version": "1.0.0",
  "description": "TypeScript SDK for YourProduct API",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "bin": {
    "yourproduct": "./dist/cli.js"
  },
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/",
    "prepublishOnly": "npm run build && npm test"
  },
  "keywords": [
    "yourproduct",
    "api",
    "sdk",
    "typescript"
  ],
  "author": "Your Company",
  "license": "MIT",
  "dependencies": {
    "commander": "^11.0.0"
  },
  "devDependencies": {
    "@types/jest": "^29.0.0",
    "@types/node": "^20.0.0",
    "jest": "^29.0.0",
    "typescript": "^5.0.0",
    "eslint": "^8.0.0"
  },
  "files": [
    "dist/",
    "README.md",
    "EXAMPLES.md"
  ]
}
```

---

## Examples

### ‚úÖ GOOD: GiDanc Health Check SDK

**What makes it excellent:**

1. **Type-Safe Client:**
```typescript
const client = new HealthCheckClient({
  apiKey: 'hck_your_api_key_here',
});

const result = await client.runTest({
  targetAi: {
    provider: 'anthropic',
    model: 'claude-3-opus-20240229',
    apiKey: 'sk-ant-xxx',
  },
});
```

2. **Comprehensive Type Definitions:**
- `TestConfig`, `TestResult`, `TestStatus`, `HistoryFilters`
- Typed errors: `AuthenticationError`, `RateLimitError`, `ValidationError`
- Full IntelliSense support

3. **Developer Experience:**
- Simple `runTest()` for basic use
- Advanced `startTest()` + `waitForCompletion()` for control
- Progress callbacks for real-time updates
- CLI tool for CI/CD

4. **Production Quality:**
- 988 lines of tests (80%+ coverage)
- Comprehensive README + EXAMPLES
- Error handling with typed exceptions
- Rate limiting and retries

---

### ‚ùå BAD: Incomplete SDK

```typescript
// ‚ùå No type safety
export function callAPI(endpoint: string, data: any): Promise<any> {
  return fetch(endpoint, {
    method: 'POST',
    body: JSON.stringify(data),
  }).then(r => r.json());
}

// Usage (no IntelliSense, no validation)
const result = await callAPI('/test', { whatever: true });
```

**Problems:**
- No type safety
- No error handling
- No authentication
- No documentation
- No CLI tool
- No tests

---

## Benefits

### Time Savings

**For Customers:**
- Integration time: **4 hours ‚Üí 30 minutes** (87% faster)
- Time to first successful API call: **2 hours ‚Üí 5 minutes**
- Debugging time: **80% reduction** (type safety catches errors)

**For Your Team:**
- Support requests: **60% reduction** (SDK handles common errors)
- Documentation burden: **50% reduction** (SDK is self-documenting)
- Onboarding new customers: **70% faster**

### Quality Improvements

- **Type Safety:** Catch errors at compile-time, not runtime
- **Consistency:** All customers use the same, tested patterns
- **Discoverability:** IntelliSense shows all available methods
- **Error Handling:** Typed exceptions with clear error messages

### ROI

**Investment:** 20-30 hours to build SDK  
**Savings:** 100-200 hours/year in reduced support and faster integrations  
**ROI:** 5-10x

---

## See Also

### Related Rules

- @060-api-standards.mdc - API endpoint design patterns
- @012-api-security.mdc - API security best practices
- @105-typescript-linter-standards.mdc - TypeScript coding standards
- @300-testing-standards.mdc - Testing requirements
- @380-comprehensive-testing-standards.mdc - Universal testing framework
- @110-api-client-standards.mdc - API client implementation patterns

### Tools & Documentation

- **`.cursor/tools/inspect-model.sh`** - Inspect Prisma models for SDK type generation
  ```bash
  ./.cursor/tools/inspect-model.sh YourModel
  # Use output to create SDK types
  ```

- **`packages/sdk-ts/`** - Reference implementation (GiDanc Health Check SDK)

### Comprehensive Guides

- **`guides/SDK-Development-Complete-Guide.md`** ‚≠ê **Essential** - Step-by-step SDK creation
- **`guides/API-Design-Guide.md`** - API design principles
- **`guides/TypeScript-Best-Practices-Guide.md`** - TypeScript patterns

### Quick Start - SDK Development

```bash
# 1. Create SDK package structure
mkdir -p packages/sdk-ts/src/__tests__
cd packages/sdk-ts

# 2. Initialize package
npm init -y
npm install --save-dev typescript @types/node jest @types/jest

# 3. Create core files
touch src/client.ts src/types.ts src/cli.ts src/index.ts
touch src/__tests__/client.test.ts

# 4. Build and test
npm run build
npm test

# 5. Document
touch README.md EXAMPLES.md
```

---

**Last Updated:** November 25, 2025  
**Status:** ‚úÖ Production-Ready  
**Based On:** GiDanc Health Check SDK (988 test lines, 100% type coverage)
